#include <bits/stdc++.h>

using namespace std;

const int MAXN = 5e5 + 5;
const int INF = 1e9 + 7;

int adj[MAXN];
vector<int> pv[MAXN];
vector<int> cnt[MAXN];
int vis[MAXN];
int ft[MAXN];
bool cy[MAXN];
int l[MAXN];
int d[MAXN];
int tot[MAXN];


void dfs (int u, int rt)
{
    d[u] = 1; //number of nodes on path to root / size of the path generated by this thing
    for (auto x : pv[u])  
    {
        dfs(x, rt);
        d[u] = max(d[u], d[x] + 1);
    }

    sort (pv[u].begin(), pv[u].end(), [&](int x, int y)
    {
        return d[x] > d[y];
    });

    for (int i = 1 - cy[u]; i < pv[u].size(); i++)
    {
        //these paths end at pv[u][i], so we are good
        cnt[rt].push_back(d[pv[u][i]]);
    }
}

int main()
{
    int n;
    cin >> n;
    for (int i = 0; i < n; i++)
    {
        ft[i] = -1;
        l[i] = -1;
    }

    for (int i = 0; i < n; i++)
    {
        cin >> adj[i];
        adj[i]--;
        pv[adj[i]].push_back(i);
    }
    int ct = 0;
    vector<int> cyc; //store one node in the cycle corresponding to each component
    for (int i = 0; i < n; i++)
    {
        int st = ct;
        if (vis[i])
        {
            continue;
        }
        ft[i] = ct++;
        vis[i] = 1;
        int cv = adj[i];
        while (true)
        {
            if (vis[cv])
            {
                if (ft[cv] >= st)
                {
                    cyc.push_back(cv);
                }
                break;
            }
            ft[cv] = ct++;
            vis[cv] = 1;
            cv = adj[cv];
        }
    }


    for (int i = 0; i < n; i++)
    {
        vis[i] = 0;
    }

    //get the length of each cycle and mark the cycle vertices as cycle vertices
    for (auto x : cyc)
    {
        //mark each vertex as a cycle vertex
        cy[x] = 1;
        l[x] = x;
        int cv = adj[x];
        int sz = 1;
        while (cv != x)
        {
            l[cv] = x;
            cy[cv] = 1;
            sz++;
            cv = adj[cv];
        }
        tot[x] = sz;
    }


    //remove all cycle vertices from each adjacency list
    for (int i = 0; i < n; i++)
    {
        sort(pv[i].begin(), pv[i].end(), [&](int x, int y)
        {
            return cy[x] < cy[y]; 
        });

        while (!pv[i].empty() && cy[pv[i].back()])
        {
            pv[i].pop_back();
        }
        vis[i] = 0;
    }

    //for each cycle vertex, run a dfs to try to decompose the tree associated with it into paths
    //next, push this length into the vector associated with the representative of this vertex
    for (int i = 0; i < n; i++)
    {
        if (cy[i])
        {
            dfs(i, l[i]);
        }
    }

    vector<int> ans(n + 1, INF);
    vector<int> pos; //possible component things
    for (int i = 0; i < n; i++)
    {
        if (l[i] == i)
        {
            sort(cnt[i].begin(), cnt[i].end());
            for (int j = 1; j <= tot[i]; j++)
            {
                ans[j] = 1;
            }
        }
    }

    for (int i = 0; i < n; i++)
    {
        if (l[i] == i)
        {
            if (!cnt[i].empty())
            {
                for (int j = tot[i]; j <= tot[i] + cnt[i].back(); j++)
                {
                    ans[j] = 0;
                }
                pos.push_back(tot[i] + cnt[i].back());
                cnt[i].pop_back();
                for (auto x : cnt[i])
                {
                    pos.push_back(x);
                }
            } else
            {
                ans[tot[i]] = 0;
                pos.push_back(tot[i]);
            }
        }
    }
    sort(pos.rbegin(), pos.rend());

    int cur = pos[0];
    int cind = 1;
    for (int i = 1; i <= n; i++)
    {
        while (cind < pos.size() && cur < i)
        {
            cur += pos[cind];
            cind++;
        }

        if (i < pos[0])
        {
            cout << ans[i] << " ";
            continue;
        }

        cout << min(ans[i], cind-1) << " ";
    }

    cout << "\n";




}